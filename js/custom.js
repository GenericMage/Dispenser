/** * @file Application for interacting with Peng Protocol smart contracts on Polygon * @version 0.5.2 */ /** * Constants for contract addresses and network configuration * @namespace Constants */ class Constants { static FREE_BASER_ADDRESS = "0x3bA341ea464ae63372Bfe60B572E677CE0d9a3Ba"; static DISPENSER_ADDRESS = "0xB709FafF4f731bfD767354738cB8A38D08a92920"; static PENG_NFT_ADDRESS = "0xB1a58fae5C0E952F64f9433789a350b8ab54D6D0"; static WPOL_ADDRESS = "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270"; static LUSD_ADDRESS = "0xF0FD398Ca09444F771eC968d9cbF073a744A544c"; static POLYGON_CHAIN_ID = 137; static POLYGON_RPCS = [ "https://polygon-rpc.com", "https://rpc-mainnet.matic.network", "https://matic-mainnet.chainstacklabs.com", "https://rpc-mainnet.maticvigil.com", "https://polygon-mainnet.g.alchemy.com/v2/demo" ]; static POLYGON_NETWORK_CONFIG = { chainId: `0x${this.POLYGON_CHAIN_ID.toString(16)}`, chainName: "Polygon PoS", nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 }, rpcUrls: this.POLYGON_RPCS, blockExplorerUrls: ["https://polygonscan.com"] }; } /** * Smart contract ABIs for interacting with blockchain * @namespace Abis */ class Abis { static FREE_BASER_ABI = [{ name: "freebase", type: "function", inputs: [], outputs: [], stateMutability: "nonpayable" }]; static DISPENSER_ABI = [{ name: "convert", type: "function", inputs: [{ name: "amount", type: "uint256" }], outputs: [], stateMutability: "nonpayable" }]; static PENG_NFT_ABI = [{ name: "balanceOf", type: "function", inputs: [{ name: "owner", type: "address" }], outputs: [{ name: "", type: "uint256" }], stateMutability: "view" }]; static WPOL_ABI = [ { name: "approve", type: "function", inputs: [{ name: "guy", type: "address" }, { name: "wad", type: "uint256" }], outputs: [{ name: "", type: "bool" }], stateMutability: "nonpayable" }, { name: "allowance", type: "function", inputs: [{ name: "", type: "address" }, { name: "", type: "address" }], outputs: [{ name: "", type: "uint256" }], stateMutability: "view" } ]; static LUSD_ABI = [{ name: "getPrice", type: "function", inputs: [], outputs: [{ name: "", type: "int256" }], stateMutability: "view" }]; } /** * Utility functions for the application * @namespace Utils */ class Utils { static debounce(func, wait) { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), wait); }; } static truncateAddress(address) { if (!address) return null; return `${address.slice(0, 6)}...${address.slice(-4)}`; } } /** * State management for persisting data between sessions * @namespace StateManager */ class StateManager { static saveState(state) { const { provider, client, ...persistable } = state; localStorage.setItem('appState', JSON.stringify(persistable)); } static loadState() { return JSON.parse(localStorage.getItem('appState') || '{}'); } } /** * Handles wallet connection and blockchain interactions * @class WalletManager */ class WalletManager { constructor(appState) { this.appState = appState; this.publicClient = window.viem.createPublicClient({ chain: window.viem.polygon, transport: window.viem.http(Constants.POLYGON_RPCS[0]) }); } async initializeProvider(account) { console.log("Initializing provider..."); this.appState.account = account; this.appState.truncatedAccount = Utils.truncateAddress(account); this.appState.isConnected = true; const chainId = await this.publicClient.getChainId(); this.appState.isPolygon = chainId === Constants.POLYGON_CHAIN_ID; await this.refreshPengBalance(); await this.updateWpolCost(); StateManager.saveState(this.appState); } async connectBrowserWallet() { try { console.log("Connecting to browser wallet..."); if (!window.ethereum) throw new Error("No wallet detected"); this.appState.provider = window.ethereum; this.appState.client = window.viem.createWalletClient({ chain: window.viem.polygon, transport: window.viem.custom(window.ethereum) }); const accounts = await this.appState.client.request({ method: 'eth_requestAccounts' }); await this.initializeProvider(accounts[0]); document.getElementById('walletModal').classList.remove('show'); } catch (e) { console.error("Connection failed:", e); alert(`Connection failed: ${e.message}`); } } async connectQRCode() { try { console.log("Starting WalletConnect v2..."); if (!window.WalletConnectEthereumProvider) throw new Error("WalletConnectEthereumProvider not loaded"); const wcProvider = await window.WalletConnectEthereumProvider.init({ projectId: "077efc6af839a38187993203557e4aad", // Your WalletConnect Cloud project ID chains: [Constants.POLYGON_CHAIN_ID], showQrModal: false, // Manual QR handling rpcMap: { 137: Constants.POLYGON_RPCS[0] } }); await wcProvider.connect(); this.appState.wcUri = wcProvider.signer.session?.peer.metadata.url || wcProvider.uri; window.QRCode.toCanvas(document.getElementById('qrCanvas'), this.appState.wcUri, { width: 200 }, (error) => { if (error) console.error("QR Error:", error); }); this.appState.provider = wcProvider; this.appState.client = window.viem.createWalletClient({ chain: window.viem.polygon, transport: window.viem.custom(wcProvider) }); const accounts = await this.appState.client.getAddresses(); await this.initializeProvider(accounts[0]); document.getElementById('qrModal').classList.remove('show'); } catch (e) { console.error("QR code connection failed:", e); alert(`Connection failed: ${e.message}`); } } async handleNetworkSelection() { console.log("Network selection clicked"); if (!this.appState.isConnected) { document.getElementById('walletModal').classList.add('show'); return; } try { const chainId = await this.publicClient.getChainId(); if (chainId !== Constants.POLYGON_CHAIN_ID) { await this.appState.client.switchChain({ id: Constants.POLYGON_CHAIN_ID }); } this.appState.isPolygon = (await this.publicClient.getChainId()) === Constants.POLYGON_CHAIN_ID; StateManager.saveState(this.appState); } catch (e) { console.error("Network switch failed:", e); alert(`Network switch failed: ${e.message}`); } } disconnectWallet() { console.log("Disconnecting wallet..."); if (this.appState.provider?.disconnect) this.appState.provider.disconnect(); this.appState.isConnected = false; this.appState.account = null; this.appState.truncatedAccount = null; this.appState.isPolygon = false; this.appState.pengBalance = 0; this.appState.provider = null; this.appState.client = null; this.appState.wcUri = null; this.appState.showDisconnectModal = false; document.getElementById('disconnectModal').classList.remove('show'); StateManager.saveState(this.appState); } async refreshPengBalance() { if (!this.appState.client) return; try { const balance = await this.publicClient.readContract({ address: Constants.PENG_NFT_ADDRESS, abi: Abis.PENG_NFT_ABI, functionName: 'balanceOf', args: [this.appState.account] }); this.appState.pengBalance = Number(balance); StateManager.saveState(this.appState); } catch (e) { console.error("Failed to fetch Peng balance:", e); this.appState.pengBalance = 0; } } } /** * Handles LUSD dispensing functionality * @class DispenserManager */ class DispenserManager { constructor(appState) { this.appState = appState; this.publicClient = window.viem.createPublicClient({ chain: window.viem.polygon, transport: window.viem.http(Constants.POLYGON_RPCS[0]) }); } async updateWpolCost() { console.log("Updating WPOL cost..."); try { const lusdAmount = BigInt(Math.round((this.appState.dispenseAmount || "0") * 1e18)); const client = this.appState.client || this.publicClient; const price = await client.readContract({ address: Constants.LUSD_ADDRESS, abi: Abis.LUSD_ABI, functionName: 'getPrice' }); const wpolAmount = (lusdAmount * BigInt(10 ** 10)) / BigInt(price); // Normalize 8 to 18 decimals this.appState.wpolCost = `${Number(wpolAmount) / 1e18} WPOL`; if (this.appState.client) { const allowance = await this.publicClient.readContract({ address: Constants.WPOL_ADDRESS, abi: Abis.WPOL_ABI, functionName: 'allowance', args: [this.appState.account, Constants.DISPENSER_ADDRESS] }); this.appState.needsApproval = wpolAmount > allowance; } else { this.appState.needsApproval = false; } StateManager.saveState(this.appState); } catch (e) { console.error("Error calculating WPOL cost:", e); this.appState.wpolCost = "Error"; this.appState.needsApproval = false; } } executeDispenseOrApprove = Utils.debounce(async function() { console.log("Executing dispense or approve..."); if (!this.appState.client || !this.appState.isPolygon) { alert("Connect wallet to Polygon first"); return; } try { const lusdAmount = BigInt(Math.round(this.appState.dispenseAmount * 1e18)); const price = await this.publicClient.readContract({ address: Constants.LUSD_ADDRESS, abi: Abis.LUSD_ABI, functionName: 'getPrice' }); const wpolAmount = (lusdAmount * BigInt(10 ** 10)) / BigInt(price); if (this.appState.needsApproval) { const hash = await this.appState.client.writeContract({ address: Constants.WPOL_ADDRESS, abi: Abis.WPOL_ABI, functionName: 'approve', args: [Constants.DISPENSER_ADDRESS, wpolAmount] }); await this.publicClient.waitForTransactionReceipt({ hash }); this.appState.needsApproval = false; await this.updateWpolCost(); } else { const hash = await this.appState.client.writeContract({ address: Constants.DISPENSER_ADDRESS, abi: Abis.DISPENSER_ABI, functionName: 'convert', args: [lusdAmount] }); await this.publicClient.waitForTransactionReceipt({ hash }); this.appState.dispenseAmount = "1.0"; document.getElementById('dispenserModal').classList.remove('show'); } StateManager.saveState(this.appState); } catch (e) { console.error("Dispense/Approve failed:", e); alert(`Action failed: ${e.message}`); } }, 300); } /** * Handles freebase functionality * @class FreebaseManager */ class FreebaseManager { constructor(appState) { this.appState = appState; } executeFreebase = Utils.debounce(async function() { console.log("Executing freebase..."); if (!this.appState.client || !this.appState.isPolygon) { alert("Connect wallet to Polygon first"); return; } try { const hash = await this.appState.client.writeContract({ address: Constants.FREE_BASER_ADDRESS, abi: Abis.FREE_BASER_ABI, functionName: 'freebase' }); await window.viem.createPublicClient({ chain: window.viem.polygon, transport: window.viem.http(Constants.POLYGON_RPCS[0]) }).waitForTransactionReceipt({ hash }); console.log("Freebase executed"); } catch (e) { console.error("Freebase failed:", e); alert(`Freebase failed: ${e.message}`); } }, 300); } /** * Main application class that integrates all managers * @class App */ class App { static createAppState() { const state = StateManager.loadState(); const appState = { isConnected: state.isConnected || false, account: state.account || null, truncatedAccount: state.truncatedAccount || null, isPolygon: state.isPolygon || false, pengBalance: state.pengBalance || 0, dispenseAmount: state.dispenseAmount || "1.0", wpolCost: state.wpolCost || "0 WPOL", needsApproval: state.needsApproval || false, showDisconnectModal: false, isDarkMode: state.isDarkMode || window.matchMedia('(prefers-color-scheme: dark)').matches, provider: null, client: null, wcUri: null }; const walletManager = new WalletManager(appState); const dispenserManager = new DispenserManager(appState); const freebaseManager = new FreebaseManager(appState); return { ...appState, init() { console.log("Initializing app state..."); document.body.classList.toggle("dark-mode", this.isDarkMode); if (this.isConnected && this.account) walletManager.initializeProvider.call(walletManager, this.account); dispenserManager.updateWpolCost.call(dispenserManager); }, connectBrowserWallet: walletManager.connectBrowserWallet.bind(walletManager), connectQRCode: walletManager.connectQRCode.bind(walletManager), handleNetworkSelection: walletManager.handleNetworkSelection.bind(walletManager), disconnectWallet: walletManager.disconnectWallet.bind(walletManager), showDispenseModal() { console.log("Showing dispense modal"); dispenserManager.updateWpolCost.call(dispenserManager); document.getElementById('dispenserModal').classList.add('show'); }, updateWpolCost: dispenserManager.updateWpolCost.bind(dispenserManager), executeDispenseOrApprove: dispenserManager.executeDispenseOrApprove.bind(dispenserManager), executeFreebase: freebaseManager.executeFreebase.bind(freebaseManager), copyUri: async function() { if (this.wcUri) { try { await navigator.clipboard.writeText(this.wcUri); console.log("URI copied to clipboard:", this.wcUri); alert("URI copied to clipboard"); } catch (e) { console.error("Clipboard copy failed:", e); alert("Failed to copy URI"); } } else { console.log("No URI available to copy"); alert("No URI available"); } }, toggleDarkMode() { console.log("Toggling dark mode..."); this.isDarkMode = !this.isDarkMode; document.body.classList.toggle("dark-mode", this.isDarkMode); StateManager.saveState(this); } }; } } // Alpine.js integration window.addEventListener("load", () => { const deps = { viem: window.viem, WalletConnectEthereumProvider: window.WalletConnectEthereumProvider, QRCode: window.QRCode }; if (!deps.viem || !deps.WalletConnectEthereumProvider || !deps.QRCode) { console.error("Dependencies not loaded:", { viem: !!deps.viem, WalletConnectEthereumProvider: !!deps.WalletConnectEthereumProvider, QRCode: !!deps.QRCode }); alert("App failed to load dependencies. Please refresh."); return; } document.addEventListener("alpine:init", () => { Alpine.data("appState", () => App.createAppState()); }); console.log("custom.js loaded"); });